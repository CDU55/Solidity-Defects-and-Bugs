// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol";
contract SignatureBasedVulnerabilityFixed {

mapping(address=>bool) private council;
address private councilLeader;
uint private councilCount;
uint256 public currentNonce;

constructor()
{
    councilLeader=msg.sender;
    council[msg.sender]=true;
    councilCount=1;
}

function addToCouncil(address candidate) external
{
    require(msg.sender==councilLeader,'Only the council leader can add new members');
    require(council[candidate]==false,'This address already is a member of the council');
    councilCount++;
    council[candidate]=true;
}

function removeFromCouncil(address councilMember) external
{
    require(msg.sender==councilLeader,'Only the council leader can remove members');
    require(council[councilMember]==true,'This address is not a member of the council');
    councilCount--;
    council[councilMember]=false;
}

function directFunds(address target, uint amount,uint nounce, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external
{
  require(v.length > councilCount/2,'Half+1 of the council members must sign');
  require(councilCount>=3,'The council must have at least 3 member before proposing investments');
  require(nounce == currentNonce+1);
  bytes32 hashData = keccak256(abi.encodePacked(target, amount, nounce));
  for (uint index = 0; index < v.length; index++) {
    address councilMember = ecrecover(hashData, v[index], r[index], s[index]);
    require(council[councilMember]==true,'Not all signers are members of the council');
  }
  currentNonce=currentNonce+1;
  payable(target).transfer(amount);
}

}